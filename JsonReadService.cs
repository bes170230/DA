/* CS 4385, Spring 2021
 * 
 * Teammates: Brad Stover, Ada Zuniga, Jane Shen, Luke Padgett, Eric Perez
 * 
 * Purpose: The purpose of this application is to analyze data from a .JSON
 * file that was generated by the TimeTracker app. 
 * 
 * Details: The .JSON data contains user activity pertaining to the following 
 * variables: timestamp; username; MAC address; IP hostname; IP address; 
 * operating system; process ID; URL (if applicable); title; duration 
 * (with time idle & active); and screenshot filename.
 * 
 * However, the scope of this application is limited to the following
 * variables: timestamp, duration, title, and URL. This was done for the
 * sake of utmost relevance to business process identification.
 * 
 * Procedure: The user is prompted to specify the location of the .JSON file.
 * After this--assuming a successful file read--the (ordered) number of 
 * occurrences of each user activity is displayed. Next, these activities 
 * and their corresponding parameters are displayed in chronological order. 
 * After this, all activities are sorted by duration and displayed. Total 
 * duration of all activities is then calculated and displayed.
 * 
 * Only browser-related activities are considered thereafter. Browser-related
 * activities are first sorted by duration in descending order (with their
 * corresponding parameter values included in the list). Next, browser activities
 * are displayed via sorting by duration AND grouping by website. The total
 * duration of all browser activities is then calculated & displayed.
 * 
 * At the end, the number of occurrences of each URL is tallied up and displayed.
 * The number of occurrences of each website title is also counted
 * and displayed. This concludes the initial analysis program. The next 
 * milestone of this program (for students in future semesters) will be to
 * read the .JSON file from MongoDB rather than from the user's local
 * machine. Currently, the .JSON file is read from the following file path:
 * C:\Users\*username_here*\AppData\Roaming\Logs\Outputyyyy_mm_dd.json.
 * 
 * We wish to issue a special thank-you to Dr. Hill of Fellows Consulting
 * Group for his time, patience, and guidance.
 */
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft;
using System.Linq;
public class JsonReadService
{
    // The ProcessModel class provides getter & setter functions for each
    // process parameter. It also provides a toString() function that neatly
    // formats all data.
    public class ProcessModel
    {
        public DateTime TimeStamp { get; set; }
        public string Username { get; set; }
        public string MacAddress { get; set; }
        public string IPHostName { get; set; }
        public string IPAddress { get; set; }
        public string Id { get; set; }
        public string OS { get; set; }
        public string Process { get; set; }
        public string Url { get; set; }
        public string Title { get; set; }
        public TimeSpan Duration { get; set; }
        public TimeSpan Idle { get; set; }
        public TimeSpan Active { get; set; }
        public string ScreenShotFileName { get; set; }
        public override string ToString()
        {
            return Environment.NewLine + "   Title: " + Title + Environment.NewLine + 
                "      Duration: " + Duration +
                " (Active: " + Active + ", Idle: " + Idle + ")" + Environment.NewLine + 
                "         Timestamp: " + TimeStamp + Environment.NewLine + 
                "               URL: " + Url;
        }
    }
    // The ProcessList class provides full functionality when working with a
    // a list of objects representing the process parameters.
    public class ProcessList
    {
        public List<ProcessList> processlist { get; set; }
    }
    
    // The ReadJsonFile class takes in a .JSON file path from the user, reads it into
    // a list, and then clarifies that list. It also performs various sorting, grouping,
    // and calculations, as will be seen below.
    public static void ReadJsonFile(string jsonFileIn)
    {
        // Load and deserialize file
        dynamic jsonFile = JsonConvert.DeserializeObject(File.ReadAllText(jsonFileIn));
        var stringJSON = File.ReadAllText(jsonFileIn);

        // Convert .JSON data to list
        var processList = JsonConvert.DeserializeObject<List<ProcessModel>>(stringJSON);

        // Clean up title values
        foreach (var item in processList)
        {
            if (item.Title == null || item.Title == "" || item.Title == "-")
            {
                item.Title = "?";
            }
        }

        // Count number of occurrences of each title, then display them in descending order
        var g = processList.GroupBy(i => i.Title).OrderByDescending(group => group.Count());

        Console.WriteLine("-------------------------------------------------------");
        Console.WriteLine("");
        Console.WriteLine("Number of Occurrences of Each User Activity:" + Environment.NewLine);
        foreach (var grp in g)
        {
            Console.WriteLine("{0} : {1}", grp.Key, grp.Count());
        }

        // Show all activities in chronological order first
        int index = 0;
        TimeSpan TotalDuration = processList[index].Duration;
        TimeSpan TotalActive = processList[index].Active;
        TimeSpan TotalIdle = processList[index].Idle;
        Console.WriteLine("");
        Console.WriteLine("-------------------------------------------------------");
        Console.WriteLine("All Activities in Chronological Order:");
        foreach (var item in processList.OrderBy(x => x.TimeStamp))
        {
            Console.WriteLine($"{index + 1}) {item}");
            index++;
        }

        // Show all activities sorted by duration (in descending order):
        Console.WriteLine("");
        Console.WriteLine("-------------------------------------------------------");
        index = 0;
        Console.WriteLine("All Activities, Sorted by Duration (in Descending Order):" +
            Environment.NewLine);
        foreach (var item in processList.OrderByDescending(x => x.Duration))
        {
            Console.WriteLine($"{index + 1}) {item}");
            index++;
            TotalDuration += item.Duration;
            TotalActive += item.Active;
            TotalIdle += item.Idle;
        }
        Console.WriteLine("");
        Console.WriteLine("Total Duration of All Activities: " 
            + TotalDuration + Environment.NewLine + " (Active: " + TotalActive + 
            ", Idle: " + TotalIdle + ")");
        Console.WriteLine("");
        Console.WriteLine("-------------------------------------------------------");
        Console.WriteLine("");

        // Filter activities so that only browser-related activities are present.
        var webProcessList = new List<ProcessModel>();
        foreach (var item in processList)
        {
            if (item.Url != "" && item.Title != "?")
            {
                webProcessList.Add(item);
            }
        }
        index = 0;
        TimeSpan temp = webProcessList[index].Duration;

        // Order browser-related activities by duration, in descending order:
        webProcessList = webProcessList.OrderByDescending(x => x.Duration).ToList();
        Console.WriteLine("Browser Activities, Sorted by Duration in Descending Order:");
        Console.WriteLine("");
        foreach (var item in webProcessList.OrderByDescending(x => x.Duration))
        {
            Console.WriteLine($"{index + 1}) {item}");
            index++;
        }

        // Filter out blank/unknown titles and URLs from list.
        var perSiteList = new List<ProcessModel>();
        foreach (var item in webProcessList)
        {
            if (item.Title != "?" && item.Url != "")
            perSiteList.Add(item);
        }

        Console.WriteLine("");
        Console.WriteLine("-------------------------------------------------------");
        Console.WriteLine("");

        // Display browser activities, with sorting by duration and grouping by (website) title.
        index = 0;
        Console.WriteLine("Browser activities, sorted by duration and grouped by website:");
        Console.WriteLine("");
        TotalDuration = perSiteList[index].Duration;
        TotalActive = perSiteList[index].Active;
        TotalIdle = perSiteList[index].Idle;
        foreach (var item in webProcessList.OrderByDescending(x => x.Url))
        {
            Console.WriteLine($"{index + 1}) {item}");
            index++;
            TotalDuration += item.Duration;
            TotalActive += item.Active;
            TotalIdle += item.Idle;
        }

        // Show total duration of all browser-related activities.
        Console.WriteLine(Environment.NewLine + "Total Duration of All Browser Activities: " 
            + TotalDuration + Environment.NewLine + " (Active: " + TotalActive + ", Idle: " 
            + TotalIdle + ")" + Environment.NewLine);
     
        // Filter all URLs and titles.
        var siteCountList = new List<ProcessModel>();
        foreach (var item in processList)
        {
            if (item.Url != "" && item.Title != "?")
            {
                siteCountList.Add(item);
            }
        }

        // Show number of occurrences of each URL, sorted by descending tally:
        g = siteCountList.GroupBy(i => i.Url).OrderByDescending(group => group.Count());
        Console.WriteLine("Number of Occurrences of Each URL:" + Environment.NewLine);
        foreach (var grp in g)
        {
            Console.WriteLine("{0} : {1}", grp.Key, grp.Count());
        }
        Console.WriteLine("");
        Console.WriteLine("Number of Occurrences of Each Title:" + Environment.NewLine);

        var titleCountList = new List<ProcessModel>();
        foreach (var item in processList)
        {
            if (item.Url != "" && item.Title != "?")
            {
                titleCountList.Add(item);
            }
        }
        // Show number of occurrences of each (website) title, sorted by descending tally:
        g = titleCountList.GroupBy(i => i.Title).OrderByDescending(group => group.Count());

        foreach (var grp in g)
        {
            Console.WriteLine("{0} : {1}", grp.Key, grp.Count());
        }
        Console.WriteLine("");
        Console.WriteLine("--------------------------------------------------------");

    }

} // end
